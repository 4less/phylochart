<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Phylochart Taxon Profiles</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/highcharts-more.js"></script>
    <style>
      :root {
        color-scheme: light;
        --ink: #1a1a1a;
        --muted: #6b6f76;
        --paper: #f6f1e8;
        --panel: #ffffff;
        --accent: #1b5e45;
        --accent-soft: rgba(27, 94, 69, 0.12);
        --shadow: 0 20px 50px rgba(15, 22, 26, 0.15);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Space Grotesk", "Trebuchet MS", sans-serif;
        color: var(--ink);
        background: radial-gradient(
            circle at 10% 20%,
            rgba(27, 94, 69, 0.12),
            transparent 48%
          ),
          radial-gradient(circle at 80% 0%, rgba(191, 111, 16, 0.12), transparent 55%),
          var(--paper);
      }

      .page {
        max-width: 1400px;
        margin: 0 auto;
        padding: 40px 32px 48px;
      }

      header {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 16px;
      }

      .logo {
        height: 44px;
        width: auto;
      }

      h1 {
        margin: 0 0 6px;
        font-size: clamp(1.6rem, 2.5vw, 2.4rem);
        letter-spacing: -0.02em;
      }

      .subtitle {
        color: var(--muted);
        margin: 0;
        font-size: 0.98rem;
      }

      .controls {
        display: flex;
        align-items: center;
        gap: 16px;
        background: var(--panel);
        padding: 20px 22px;
        border-radius: 999px;
        box-shadow: var(--shadow);
        width: 100%;
        flex-wrap: wrap;
        position: sticky;
        top: 12px;
        z-index: 6;
        margin-top: 28px;
        justify-content: center;
      }

      label {
        font-size: 0.9rem;
        color: var(--muted);
      }

      select {
        font-family: inherit;
        font-weight: 600;
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid rgba(26, 26, 26, 0.15);
        background: #fff;
        color: var(--ink);
        min-width: 140px;
      }

      input[type="number"] {
        font-family: inherit;
        font-weight: 600;
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid rgba(26, 26, 26, 0.15);
        background: #fff;
        color: var(--ink);
        width: 90px;
      }

      button {
        font-family: inherit;
        font-weight: 600;
        padding: 6px 14px;
        border-radius: 999px;
        border: 1px solid rgba(26, 26, 26, 0.15);
        background: #fff;
        color: var(--ink);
        cursor: pointer;
      }

      .charts {
        display: grid;
        grid-template-columns: minmax(0, 3fr) minmax(0, 1fr);
        gap: 18px;
        margin-top: 28px;
      }

      .charts.single {
        grid-template-columns: minmax(0, 1fr);
      }

      .loading-container {
        position: relative;
      }

      .loading-overlay {
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.88);
        border-radius: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        color: var(--muted);
        font-weight: 600;
        letter-spacing: 0.02em;
        z-index: 20;
        pointer-events: all;
        backdrop-filter: blur(1px);
      }

      .loading-overlay[hidden] {
        display: none !important;
      }

      .spinner {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid rgba(27, 94, 69, 0.2);
        border-top-color: var(--accent);
        animation: spin 0.9s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .chart-card {
        background: var(--panel);
        border-radius: 18px;
        padding: 14px 12px 6px;
        box-shadow: var(--shadow);
      }

      .chart-card.full-width {
        grid-column: 1 / -1;
      }

      .chart-title {
        font-weight: 600;
        font-size: 0.95rem;
        color: var(--muted);
        margin: 6px 0 10px 6px;
      }

      #taxonChartPanel {
        display: grid;
        gap: 12px;
      }

      #taxonChartPanel.facets {
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      .panel-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 0 0 8px 6px;
        flex-wrap: wrap;
        position: sticky;
        top: 12px;
        z-index: 5;
        background: var(--panel);
        padding: 8px 10px;
        border-radius: 12px;
        box-shadow: 0 8px 20px rgba(15, 22, 26, 0.08);
      }

      .sample-toggle-wrapper {
        display: flex;
        justify-content: center;
        margin: 12px 0 6px;
      }

      #status {
        margin-top: 16px;
        color: var(--muted);
      }

      @media (max-width: 980px) {
        header {
          grid-template-columns: 1fr;
        }

        .controls {
          justify-self: start;
        }

        .charts {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <header>
        <div>
          <img
            src="assets/logo_horizonal_export_white.svg"
            alt="Taxon profiles by sample"
            class="logo"
          />
          <p class="subtitle">
            Stacked bar view of taxa abundance with rank filtering.
          </p>
        </div>
      </header>
      <div class="controls">
        <label for="rankSelect">Rank</label>
        <select id="rankSelect"></select>
        <label for="groupSelect">Group by</label>
        <select id="groupSelect"></select>
        <label for="taxonOrderSelect">Taxon order</label>
        <select id="taxonOrderSelect"></select>
        <label for="taxonPinSelect">Pin taxon</label>
        <select id="taxonPinSelect"></select>
        <label for="topNInput">Top N</label>
        <input id="topNInput" type="number" min="1" step="1" value="15" />
        <button id="taxonRefresh" type="button">Refresh</button>
      </div>

      <div class="charts loading-container" id="mainCharts">
        <div class="chart-card">
          <div class="chart-title">Relative abundance</div>
          <div id="relativeChart"></div>
        </div>
        <div class="chart-card" id="absoluteCard">
          <div class="chart-title">Absolute abundance</div>
          <div id="absoluteChart"></div>
        </div>
        <div class="loading-overlay" id="mainChartsLoading" hidden>
          <span class="spinner" aria-hidden="true"></span>
          Loading taxon profiles...
        </div>
      </div>
      <div class="sample-toggle-wrapper">
        <button id="sampleToggle" type="button">Show all</button>
      </div>
      <div class="charts">
        <div class="chart-card full-width loading-container" id="taxonPanelCard">
          <div class="chart-title">Selected taxon by condition</div>
          <div class="panel-controls">
            <label for="conditionSelect">x-Axis</label>
            <select id="conditionSelect"></select>
            <label for="abundanceTypeSelect">Abundance</label>
            <select id="abundanceTypeSelect"></select>
            <label for="taxonScaleSelect">Scale</label>
            <select id="taxonScaleSelect"></select>
            <label for="colorConditionSelect">Facet by</label>
            <select id="colorConditionSelect"></select>
            <button id="taxonRefreshPanel" type="button">Refresh</button>
          </div>
          <div id="taxonChartPanel"></div>
          <div class="loading-overlay" id="taxonPanelLoading" hidden>
            <span class="spinner" aria-hidden="true"></span>
            Loading selected taxon...
          </div>
        </div>
      </div>

      <div id="status">Loading embedded taxa data...</div>
    </div>
    <!-- TAXA_DATA -->

    <script>
      const TOP_N = 15;
      const CHART_MARGIN_TOP = 48;
      const CHART_MARGIN_BOTTOM = 180;
      const GROUP_PADDING = 0.06;
      const POINT_PADDING = 0.02;
      const LEGEND_MARGIN_PAD = 90;
      const PALETTE = [
        "#1b5e45",
        "#6b3fa0",
        "#a34a3b",
        "#0f7c90",
        "#d6a21e",
        "#4372d6",
        "#bf3a6f",
        "#1f8f5f",
        "#8c5e12",
        "#5862a4",
        "#b44a1f",
        "#2180a4",
        "#6a8f19",
        "#9b2f2f",
        "#2c6f62",
        "#3f3f3f",
      ];

      const state = {
        rows: [],
        ranks: [],
        metaColumns: [],
        groupBy: "None",
        taxonOrder: "total_desc",
        pinnedTaxon: null,
        legendMarginBottom: CHART_MARGIN_BOTTOM,
        taxonCondition: "All",
        taxonAbundanceType: "RelativeAbundance",
        taxonScale: "linear",
        taxonColorCondition: "All",
        topN: 15,
        sampleLimit: 10,
        showAllSamples: false,
        activeRank: null,
        mainPending: null,
        mainDirty: false,
        taxonPending: null,
        taxonDirty: false,
        charts: {},
      };

      // Parse embedded TSV into row objects and ensure an "All" column exists.
      function parseTSV(text) {
        const lines = text.trim().split(/\r?\n/);
        const header = lines[0].split("\t");
        const hasAll = header.includes("All");
        const fullHeader = hasAll ? header : [...header, "All"];
        return lines.slice(1).map((line) => {
          const cols = line.split("\t");
          const row = {};
          fullHeader.forEach((key, idx) => {
            if (key === "All") {
              row[key] = "All";
              return;
            }
            row[key] = cols[idx];
          });
          row.Abundance = Number(row.Abundance || 0);
          return row;
        });
      }

      function sampleLabel(row) {
        return row.Sample || `${row.IDGroup}|${row.Source}|${row.Community}|${row.Treatment}`;
      }

      function getMetaColumns(rows) {
        if (!rows.length) return [];
        const excluded = new Set([
          "Taxon",
          "Rank",
          "Abundance",
          "Type",
          "Sample",
        ]);
        return Object.keys(rows[0]).filter((key) => !excluded.has(key));
      }

      function isGroupLabel(value) {
        return typeof value === "string" && value.startsWith("__GROUP__:");
      }

      function limitSampleOrder(order, limit) {
        if (!Number.isFinite(limit) || limit <= 0) {
          return { order, groupFlags: order.map((value) => isSpacerLabel(value) || isGroupLabel(value)) };
        }
        const trimmed = [];
        const flags = [];
        let count = 0;
        let currentGroup = null;
        let groupHasSample = false;
        let groupLabelAdded = false;

        order.forEach((value) => {
          if (isGroupLabel(value)) {
            currentGroup = value;
            groupHasSample = false;
            groupLabelAdded = false;
            return;
          }
          if (isSpacerLabel(value)) {
            if (groupHasSample) {
              trimmed.push(value);
              flags.push(true);
            }
            currentGroup = null;
            return;
          }
          if (count >= limit) return;
          if (currentGroup && !groupLabelAdded) {
            trimmed.push(currentGroup);
            flags.push(true);
            groupLabelAdded = true;
          }
          trimmed.push(value);
          flags.push(false);
          groupHasSample = true;
          count += 1;
        });

        return { order: trimmed, groupFlags: flags };
      }
      function isSpacerLabel(value) {
        return typeof value === "string" && value.startsWith("__SPACER__:");
      }

      function groupLabel(value) {
        return value.replace("__GROUP__:", "");
      }

      function uniqueRanks(rows) {
        const seen = new Set();
        const ranks = [];
        rows.forEach((row) => {
          if (!seen.has(row.Rank)) {
            seen.add(row.Rank);
            ranks.push(row.Rank);
          }
        });
        return ranks;
      }

      function taxaForRank(rows, rank) {
        const seen = new Set();
        rows.forEach((row) => {
          if (row.Rank !== rank) return;
          if (!seen.has(row.Taxon)) {
            seen.add(row.Taxon);
          }
        });
        return [...seen].sort((a, b) => a.localeCompare(b));
      }

      function hasTypeForRank(rank, targetType) {
        return state.rows.some((row) => {
          if (row.Rank !== rank) return false;
          const type = row.Type || "RelativeAbundance";
          return type === targetType;
        });
      }

      function resolveBaseType(rank) {
        let hasRelative = false;
        state.rows.forEach((row) => {
          if (row.Rank !== rank) return;
          const type = row.Type || "RelativeAbundance";
          if (type === "RelativeAbundance") {
            hasRelative = true;
          }
        });
        return hasRelative ? "RelativeAbundance" : "AbsoluteAbundance";
      }

      function quantile(sorted, q) {
        if (!sorted.length) return 0;
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
          return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
      }

      function computeBoxStats(values) {
        if (!values.length) return null;
        const sorted = values.slice().sort((a, b) => a - b);
        const min = sorted[0];
        const max = sorted[sorted.length - 1];
        const q1 = quantile(sorted, 0.25);
        const median = quantile(sorted, 0.5);
        const q3 = quantile(sorted, 0.75);
        return [min, q1, median, q3, max];
      }

      function stableJitter(seed, amplitude) {
        let hash = 0;
        for (let i = 0; i < seed.length; i += 1) {
          hash = (hash << 5) - hash + seed.charCodeAt(i);
          hash |= 0;
        }
        const unit = (hash >>> 0) / 0xffffffff;
        return (unit - 0.5) * amplitude;
      }

      function orderTaxa(taxaTotals, baseType, order) {
        const entries = [...taxaTotals[baseType].entries()];
        if (order === "alphabetical") {
          return entries
            .map(([taxon]) => taxon)
            .sort((a, b) => a.localeCompare(b));
        }
        if (order === "total_asc") {
          return entries
            .sort((a, b) => a[1] - b[1])
            .map(([taxon]) => taxon);
        }
        return entries
          .sort((a, b) => b[1] - a[1])
          .map(([taxon]) => taxon);
      }

      function computeRankData(rank, groupBy, taxonOrder, pinnedTaxon, topN, sampleLimit) {
        const samples = [];
        const sampleIndex = new Map();
        const types = ["RelativeAbundance", "AbsoluteAbundance"];
        const sampleTaxa = {
          RelativeAbundance: new Map(),
          AbsoluteAbundance: new Map(),
        };
        const taxaTotals = {
          RelativeAbundance: new Map(),
          AbsoluteAbundance: new Map(),
        };
        const sampleMeta = new Map();

        state.rows.forEach((row) => {
          if (row.Rank !== rank) return;
          const type = row.Type || "RelativeAbundance";
          if (!types.includes(type)) return;
          const sample = sampleLabel(row);
          if (!sampleIndex.has(sample)) {
            sampleIndex.set(sample, samples.length);
            samples.push(sample);
          }
          if (!sampleMeta.has(sample)) {
            sampleMeta.set(sample, row);
          }

          if (!sampleTaxa[type].has(sample)) {
            sampleTaxa[type].set(sample, new Map());
          }

          const taxonMap = sampleTaxa[type].get(sample);
          const current = taxonMap.get(row.Taxon) || 0;
          taxonMap.set(row.Taxon, current + row.Abundance);
          taxaTotals[type].set(
            row.Taxon,
            (taxaTotals[type].get(row.Taxon) || 0) + row.Abundance
          );
        });

        const baseType = taxaTotals.RelativeAbundance.size
          ? "RelativeAbundance"
          : "AbsoluteAbundance";
        const sortedTaxa = orderTaxa(taxaTotals, baseType, taxonOrder);

        const cutoff = Math.max(1, Number(topN) || TOP_N);
        const topTaxa = sortedTaxa.slice(0, cutoff);
        const hasOther = sortedTaxa.length > cutoff;
        let taxaList = hasOther ? [...topTaxa, "Other"] : topTaxa;
        if (pinnedTaxon && taxaList.includes(pinnedTaxon)) {
          taxaList = [pinnedTaxon, ...taxaList.filter((t) => t !== pinnedTaxon)];
        }

        const buildSeries = (type, order, groupFlags) =>
          taxaList.map((taxon, idx) => {
            const data = order.map((sample, index) => {
              if (groupFlags[index]) return null;
              const taxonMap = sampleTaxa[type].get(sample) || new Map();
              let value = 0;
              if (taxon === "Other") {
                sortedTaxa.slice(cutoff).forEach((otherTaxon) => {
                  value += taxonMap.get(otherTaxon) || 0;
                });
              } else {
                value = taxonMap.get(taxon) || 0;
              }
              return value;
            });
            return {
              name: taxon,
              data,
              color: PALETTE[idx % PALETTE.length],
            };
          });

        const order = [];
        const groupFlags = [];
        if (groupBy && groupBy !== "None") {
          const grouped = new Map();
          samples.forEach((sample) => {
            const meta = sampleMeta.get(sample) || {};
            const value = meta[groupBy] || "(Missing)";
            if (!grouped.has(value)) {
              grouped.set(value, []);
            }
            grouped.get(value).push(sample);
          });
          const groupKeys = [...grouped.keys()].sort((a, b) =>
            String(a).localeCompare(String(b))
          );
          groupKeys.forEach((key) => {
            const groupSamples = grouped.get(key).slice().sort();
            order.push(`__GROUP__:${key}`);
            groupFlags.push(true);
            groupSamples.forEach((sample) => {
              order.push(sample);
              groupFlags.push(false);
            });
            order.push(`__SPACER__:${key}`);
            groupFlags.push(true);
          });
        } else {
          samples
            .slice()
            .sort()
            .forEach((sample) => {
              order.push(sample);
              groupFlags.push(false);
            });
        }

        const limitValue = Number.isFinite(sampleLimit) ? sampleLimit : state.sampleLimit;
        const limited = state.showAllSamples
          ? { order, groupFlags }
          : limitSampleOrder(order, limitValue);

        return {
          samples: limited.order,
          relativeSeries: buildSeries(
            "RelativeAbundance",
            limited.order,
            limited.groupFlags
          ),
          absoluteSeries: buildSeries(
            "AbsoluteAbundance",
            limited.order,
            limited.groupFlags
          ),
          taxaList,
        };
      }

      function updatePinOptions(rank, groupBy, taxonOrder) {
        const data = computeRankData(
          rank,
          groupBy,
          taxonOrder,
          null,
          state.topN,
          state.sampleLimit
        );
        const taxonPinSelect = document.getElementById("taxonPinSelect");
        taxonPinSelect.innerHTML = "";
        ["None", ...data.taxaList].forEach((taxon) => {
          const option = document.createElement("option");
          option.value = taxon;
          option.textContent = taxon;
          taxonPinSelect.appendChild(option);
        });
        if (state.pinnedTaxon && !data.taxaList.includes(state.pinnedTaxon)) {
          state.pinnedTaxon = null;
        }
        taxonPinSelect.value = state.pinnedTaxon || "None";
      }

      function renderTaxonPanel(rank) {
        const condition = state.taxonCondition;
        const taxon = state.pinnedTaxon;
        const baseType = state.taxonAbundanceType;
        const scaleType = state.taxonScale;
        const epsilon = baseType === "RelativeAbundance" ? 1e-6 : 1e-2;
        const colorCondition = state.taxonColorCondition;
        const panel = document.getElementById("taxonChartPanel");

        const renderEmpty = (message) => {
          panel.classList.remove("facets");
          panel.innerHTML = '<div id="taxonChart"></div>';
          state.charts.taxon = Highcharts.chart("taxonChart", {
            chart: {
              type: "boxplot",
              height: 360,
              backgroundColor: "transparent",
            },
            title: { text: null },
            subtitle: { text: message },
            xAxis: { categories: [] },
            yAxis: { title: { text: "" } },
            legend: { enabled: false },
            series: [],
            credits: { enabled: false },
          });
        };

        if (!taxon) {
          renderEmpty("Select a taxon in the plot or dropdown.");
          return;
        }

        if (!hasTypeForRank(rank, baseType)) {
          renderEmpty("No data for the selected abundance type.");
          return;
        }

        const sampleMeta = new Map();
        const sampleValues = new Map();
        const sampleSet = new Set();
        state.rows.forEach((row) => {
          if (row.Rank !== rank) return;
          const type = row.Type || "RelativeAbundance";
          if (type !== baseType) return;
          const sample = sampleLabel(row);
          sampleSet.add(sample);
          if (!sampleMeta.has(sample)) {
            sampleMeta.set(sample, row);
          }
          if (row.Taxon !== taxon) return;
          sampleValues.set(sample, (sampleValues.get(sample) || 0) + row.Abundance);
        });

        const grouped = new Map();
        const statsBuckets = new Map();
        sampleSet.forEach((sample) => {
          const meta = sampleMeta.get(sample) || {};
          const xKey =
            condition && condition !== "All"
              ? meta[condition] || "(Missing)"
              : "All";
          if (!grouped.has(xKey)) {
            grouped.set(xKey, []);
          }
          grouped.get(xKey).push(sample);

          const colorKey =
            colorCondition && colorCondition !== "All"
              ? meta[colorCondition] || "(Missing)"
              : "All";
          if (!statsBuckets.has(colorKey)) {
            statsBuckets.set(colorKey, new Map());
          }
          const colorMap = statsBuckets.get(colorKey);
          if (!colorMap.has(xKey)) {
            colorMap.set(xKey, []);
          }
          const rawValue = sampleValues.get(sample) || 0;
          const adjustedValue =
            scaleType === "log"
              ? rawValue <= 0
                ? epsilon
                : rawValue
              : rawValue;
          colorMap.get(xKey).push(adjustedValue);
        });

        const categories = [...grouped.keys()].sort((a, b) =>
          String(a).localeCompare(String(b))
        );
        const categoryIndex = new Map();
        categories.forEach((key, index) => {
          categoryIndex.set(key, index);
        });

        const toFullStats = (stats, fullCategories, localCategories) => {
          if (fullCategories.length === localCategories.length) {
            return stats;
          }
          const statMap = new Map();
          localCategories.forEach((value, idx) => {
            statMap.set(value, stats[idx] ?? null);
          });
          return fullCategories.map((value) => statMap.get(value) ?? null);
        };

        const colorKeys = [...statsBuckets.keys()].sort((a, b) =>
          String(a).localeCompare(String(b))
        );

        const formatAxisLabel = function () {
          if (scaleType === "log") {
            if (baseType === "RelativeAbundance") {
              const pct = this.value * 100;
              if (pct < 0.01) return "<0.01%";
              if (pct < 0.1) return pct.toFixed(2) + "%";
              if (pct < 1) return pct.toFixed(1) + "%";
              return pct.toFixed(0) + "%";
            }
            return Highcharts.numberFormat(this.value, 2);
          }
          if (baseType !== "RelativeAbundance") return this.value;
          return (this.value * 100).toFixed(0) + "%";
        };

        const buildAxisMax = (stats) => {
          const dataMax = stats.length
            ? Math.max(...stats.filter(Boolean).map((row) => row[4]))
            : null;
          const maxValue =
            dataMax === null
              ? null
              : baseType === "RelativeAbundance"
                ? Math.min(1, dataMax * 1.05)
                : dataMax * 1.05;
          return scaleType === "log" && maxValue !== null
            ? Math.max(maxValue, epsilon * 10)
            : maxValue;
        };

        if (colorCondition) {
          const facetKeys = colorCondition === "All" ? ["All"] : colorKeys;
          panel.classList.add("facets");
          panel.innerHTML = facetKeys
            .map((key, idx) => `<div id="taxonFacet-${idx}"></div>`)
            .join("");
          facetKeys.forEach((key, idx) => {
            const pointBuckets = new Map();
            sampleSet.forEach((sample) => {
              const meta = sampleMeta.get(sample) || {};
              const colorKey =
                colorCondition && colorCondition !== "All"
                  ? meta[colorCondition] || "(Missing)"
                  : "All";
              if (colorKey !== key) return;
              const xKey =
                condition && condition !== "All"
                  ? meta[condition] || "(Missing)"
                  : "All";
              if (!pointBuckets.has(xKey)) {
                pointBuckets.set(xKey, []);
              }
              const rawValue = sampleValues.get(sample) || 0;
              const adjustedValue =
                scaleType === "log"
                  ? rawValue <= 0
                    ? epsilon
                    : rawValue
                  : rawValue;
              pointBuckets.get(xKey).push({
                sample,
                rawValue,
                adjustedValue,
              });
            });

            const localCategories =
              colorCondition === condition && condition !== "All"
                ? [key]
                : categories;
            const localCategoryIndex = new Map();
            localCategories.forEach((value, index) => {
              localCategoryIndex.set(value, index);
            });
            const localStats = localCategories.map((category) => {
              const points = pointBuckets.get(category) || [];
              const values =
                scaleType === "log"
                  ? points.filter((p) => p.rawValue > 0).map((p) => p.rawValue)
                  : points.map((p) => p.rawValue);
              return computeBoxStats(values);
            });
            const stats = toFullStats(localStats, categories, localCategories);
            const scatter = [];
            pointBuckets.forEach((points, xKey) => {
              const xIndex = categoryIndex.get(xKey);
              if (xIndex === undefined) return;
              points.forEach((point) => {
                scatter.push({
                  x: xIndex + stableJitter(point.sample, 0.18),
                  y: point.adjustedValue,
                  name: point.sample,
                  rawValue: point.rawValue,
                });
              });
            });

            Highcharts.chart(`taxonFacet-${idx}`, {
              chart: {
                type: "boxplot",
                height: 320,
                backgroundColor: "transparent",
              },
              title: { text: key },
              xAxis: {
                categories,
                title: { text: condition === "All" ? "" : condition },
              },
              yAxis: {
                type: scaleType === "log" ? "logarithmic" : "linear",
                min: scaleType === "log" ? epsilon / 10 : 0,
                max: buildAxisMax(stats),
                title: { text: null },
                labels: { formatter: formatAxisLabel },
              },
              legend: { enabled: false },
              tooltip: {
                formatter: function () {
                  const formatValue =
                    baseType === "RelativeAbundance"
                      ? (value) => (value * 100).toFixed(2) + "%"
                      : (value) => Highcharts.numberFormat(value, 2);
                  if (this.point && this.point.high !== undefined) {
                    return [
                      `<b>${this.category}</b><br/>`,
                      `Min: ${formatValue(this.point.low)}<br/>`,
                      `Q1: ${formatValue(this.point.q1)}<br/>`,
                      `Median: ${formatValue(this.point.median)}<br/>`,
                      `Q3: ${formatValue(this.point.q3)}<br/>`,
                      `Max: ${formatValue(this.point.high)}`,
                    ].join("");
                  }
                  const value = this.point.rawValue ?? this.y;
                  return [
                    `<b>${this.point.name}</b><br/>`,
                    `${formatValue(value)}`,
                  ].join("");
                },
              },
              series: [
                {
                  name: taxon,
                  data: stats,
                  color: PALETTE[0],
                  lineWidth: 1.5,
                },
                {
                  type: "scatter",
                  name: key,
                  data: scatter,
                  color: PALETTE[3],
                  marker: { radius: 3, lineWidth: 0 },
                  showInLegend: false,
                },
              ],
              credits: { enabled: false },
            });
          });
          return;
        }

        panel.classList.remove("facets");
        panel.innerHTML = '<div id="taxonChart"></div>';
        const pointBuckets = new Map();
        sampleSet.forEach((sample) => {
          const meta = sampleMeta.get(sample) || {};
          const xKey =
            condition && condition !== "All"
              ? meta[condition] || "(Missing)"
              : "All";
          if (!pointBuckets.has(xKey)) {
            pointBuckets.set(xKey, []);
          }
          const rawValue = sampleValues.get(sample) || 0;
          const adjustedValue =
            scaleType === "log"
              ? rawValue <= 0
                ? epsilon
                : rawValue
              : rawValue;
          pointBuckets.get(xKey).push({
            sample,
            rawValue,
            adjustedValue,
          });
        });
        const stats = categories.map((category) => {
          const points = pointBuckets.get(category) || [];
          const values =
            scaleType === "log"
              ? points.filter((p) => p.rawValue > 0).map((p) => p.rawValue)
              : points.map((p) => p.rawValue);
          return computeBoxStats(values);
        });
        const scatter = [];
        pointBuckets.forEach((points, xKey) => {
          const xIndex = categoryIndex.get(xKey);
          if (xIndex === undefined) return;
          points.forEach((point) => {
            scatter.push({
              x: xIndex + stableJitter(point.sample, 0.18),
              y: point.adjustedValue,
              name: point.sample,
              rawValue: point.rawValue,
            });
          });
        });

        state.charts.taxon = Highcharts.chart("taxonChart", {
          chart: {
            type: "boxplot",
            height: 360,
            backgroundColor: "transparent",
          },
          plotOptions: {
            boxplot: {
              pointPadding: 0.1,
              groupPadding: 0.12,
              whiskerLength: "60%",
              medianWidth: 2,
            },
            scatter: {
              marker: { radius: 3, lineWidth: 0 },
            },
          },
          title: { text: null },
          subtitle: {
            text:
              baseType === "RelativeAbundance"
                ? `${taxon} (relative abundance)`
                : `${taxon} (abundance)`,
          },
          xAxis: {
            categories,
            title: { text: condition === "All" ? "" : condition },
          },
          yAxis: {
            type: scaleType === "log" ? "logarithmic" : "linear",
            min: scaleType === "log" ? epsilon / 10 : 0,
            max: buildAxisMax(stats),
            title: {
              text:
                baseType === "RelativeAbundance"
                  ? "Relative abundance"
                  : "Abundance",
            },
            labels: { formatter: formatAxisLabel },
          },
          legend: { enabled: false },
          tooltip: {
            formatter: function () {
              const formatValue =
                baseType === "RelativeAbundance"
                  ? (value) => (value * 100).toFixed(2) + "%"
                  : (value) => Highcharts.numberFormat(value, 2);
              if (this.point && this.point.high !== undefined) {
                return [
                  `<b>${this.category}</b><br/>`,
                  `Min: ${formatValue(this.point.low)}<br/>`,
                  `Q1: ${formatValue(this.point.q1)}<br/>`,
                  `Median: ${formatValue(this.point.median)}<br/>`,
                  `Q3: ${formatValue(this.point.q3)}<br/>`,
                  `Max: ${formatValue(this.point.high)}`,
                ].join("");
              }
              const value = this.point.rawValue ?? this.y;
              return [
                `<b>${this.point.name}</b><br/>`,
                `${formatValue(value)}`,
              ].join("");
            },
          },
          series: [
            {
              name: taxon,
              data: stats,
              color: PALETTE[0],
              lineWidth: 1.5,
            },
            {
              type: "scatter",
              name: taxon,
              data: scatter,
              color: PALETTE[3],
              marker: { radius: 3, lineWidth: 0 },
              showInLegend: false,
            },
          ],
          credits: { enabled: false },
        });
      }

      function renderCharts(rank, groupBy, taxonOrder) {
        state.activeRank = rank;
        const data = computeRankData(
          rank,
          groupBy,
          taxonOrder,
          state.pinnedTaxon,
          state.topN,
          state.sampleLimit
        );
        const hasAbsolute = hasTypeForRank(rank, "AbsoluteAbundance");
        const chartsContainer = document.getElementById("mainCharts");
        const absoluteCard = document.getElementById("absoluteCard");
        if (chartsContainer) {
          chartsContainer.classList.toggle("single", !hasAbsolute);
        }
        if (absoluteCard) {
          absoluteCard.hidden = !hasAbsolute;
        }
        if (!hasAbsolute && state.charts.absolute) {
          state.charts.absolute.destroy();
          state.charts.absolute = null;
        }
        const height = Math.max(360, data.samples.length * 18 + 120);

        state.charts.relative = Highcharts.chart("relativeChart", {
          chart: {
            type: "bar",
            height,
            backgroundColor: "transparent",
            marginTop: CHART_MARGIN_TOP,
            marginBottom: CHART_MARGIN_BOTTOM,
            events: {
              render: function () {
                if (!this.legend || !this.legend.group) return;
                const legendHeight =
                  this.legend.legendHeight ||
                  this.legend.group.getBBox().height;
                const desired = Math.max(
                  CHART_MARGIN_BOTTOM,
                  legendHeight + LEGEND_MARGIN_PAD
                );
                if (this.extraBottomMargin !== desired) {
                  this.extraBottomMargin = desired;
                  state.legendMarginBottom = desired;
                  this.update({ chart: { marginBottom: desired } }, false);
                }
                if (
                  state.charts.absolute &&
                  state.charts.absolute.marginBottom !== state.legendMarginBottom
                ) {
                  state.charts.absolute.update(
                    { chart: { marginBottom: state.legendMarginBottom } },
                    false
                  );
                }
              },
            },
          },
          title: { text: null },
          subtitle: { text: `Rank: ${rank}` },
          xAxis: {
            categories: data.samples,
            title: { text: null },
            labels: {
              style: { fontSize: "11px" },
              useHTML: true,
              formatter: function () {
                if (isSpacerLabel(this.value)) return "";
                if (isGroupLabel(this.value)) {
                  return `<span style="font-weight:700;color:#4a4f57;display:block;margin:6px 0 2px;">${groupLabel(
                    this.value
                  )}</span>`;
                }
                return this.value;
              },
            },
          },
          yAxis: {
            min: 0,
            max: 1,
            title: { text: "Relative abundance" },
            labels: {
              formatter: function () {
                return (this.value * 100).toFixed(0) + "%";
              },
            },
          },
          legend: {
            align: "center",
            verticalAlign: "bottom",
            layout: "horizontal",
            itemMarginTop: 6,
            itemMarginBottom: 6,
          },
          tooltip: {
            shared: true,
            useHTML: true,
            formatter: function () {
              const hoverPoint = this.points?.[0]?.series?.chart?.hoverPoint;
              const hoverTaxon = hoverPoint ? hoverPoint.series.name : null;
              let html = `<span style="font-size:12px">${this.x}</span><br/>`;
              if (hoverTaxon) {
                html += `<span style="font-weight:600">Taxon: ${hoverTaxon}</span><br/>`;
              }
              this.points?.forEach((point) => {
                if (point.y === null || typeof point.y === "undefined") return;
                const pct = (point.y * 100).toFixed(2);
                html += `<span style="color:${point.color}">\u25CF</span> ${point.series.name}: <b>${pct}%</b><br/>`;
              });
              return html;
            },
          },
          plotOptions: {
            series: {
              stacking: "normal",
              borderWidth: 0,
              groupPadding: GROUP_PADDING,
              pointPadding: POINT_PADDING,
              cursor: "pointer",
              point: {
                events: {
                  click: function () {
                    state.pinnedTaxon = this.series.name;
                    const taxonPinSelect = document.getElementById("taxonPinSelect");
                    if (taxonPinSelect) {
                      taxonPinSelect.value = state.pinnedTaxon;
                    }
                    renderCharts(rank, state.groupBy, state.taxonOrder);
                  },
                },
              },
            },
          },
          series: data.relativeSeries,
          credits: { enabled: false },
        });

        if (!hasAbsolute) {
          return;
        }

        state.charts.absolute = Highcharts.chart("absoluteChart", {
          chart: {
            type: "bar",
            height,
            backgroundColor: "transparent",
            marginTop: CHART_MARGIN_TOP,
            marginBottom: state.legendMarginBottom,
            events: {
              render: function () {
                if (!this.legend || !this.legend.group) return;
                const legendHeight =
                  this.legend.legendHeight ||
                  this.legend.group.getBBox().height;
                const desired = Math.max(
                  CHART_MARGIN_BOTTOM,
                  legendHeight + LEGEND_MARGIN_PAD
                );
                if (this.extraBottomMargin !== desired) {
                  this.extraBottomMargin = desired;
                  this.update({ chart: { marginBottom: desired } }, false);
                }
              },
            },
          },
          title: { text: null },
          subtitle: { text: "Raw abundance" },
          xAxis: {
            categories: data.samples,
            title: { text: null },
            labels: {
              useHTML: true,
              formatter: function () {
                if (isSpacerLabel(this.value)) return "";
                if (isGroupLabel(this.value)) {
                  return `<span style="font-weight:700;color:#4a4f57;display:block;margin:6px 0 2px;">${groupLabel(
                    this.value
                  )}</span>`;
                }
                return "";
              },
            },
          },
          yAxis: {
            min: 0,
            title: { text: "Abundance" },
          },
          legend: { enabled: false },
          tooltip: {
            shared: true,
            useHTML: true,
            formatter: function () {
              const hoverPoint = this.points?.[0]?.series?.chart?.hoverPoint;
              const hoverTaxon = hoverPoint ? hoverPoint.series.name : null;
              let html = `<span style="font-size:12px">${this.x}</span><br/>`;
              if (hoverTaxon) {
                html += `<span style="font-weight:600">Taxon: ${hoverTaxon}</span><br/>`;
              }
              this.points?.forEach((point) => {
                if (point.y === null || typeof point.y === "undefined") return;
                const value = Highcharts.numberFormat(point.y, 2);
                html += `<span style="color:${point.color}">\u25CF</span> ${point.series.name}: <b>${value}</b><br/>`;
              });
              return html;
            },
          },
          plotOptions: {
            series: {
              stacking: "normal",
              borderWidth: 0,
              groupPadding: GROUP_PADDING,
              pointPadding: POINT_PADDING,
              cursor: "pointer",
              point: {
                events: {
                  click: function () {
                    state.pinnedTaxon = this.series.name;
                    const taxonPinSelect = document.getElementById("taxonPinSelect");
                    if (taxonPinSelect) {
                      taxonPinSelect.value = state.pinnedTaxon;
                    }
                    renderCharts(rank, state.groupBy, state.taxonOrder);
                  },
                },
              },
            },
          },
          series: data.absoluteSeries,
          credits: { enabled: false },
        });

      }

      function init() {
        try {
          // Load the TSV payload embedded in the HTML (script#taxaData) and build the data rows.
          const text = document.getElementById("taxaData").textContent;
          state.rows = parseTSV(text);
          state.ranks = uniqueRanks(state.rows);

          const rankSelect = document.getElementById("rankSelect");
          rankSelect.innerHTML = "";
          state.ranks.forEach((rank) => {
            const option = document.createElement("option");
            option.value = rank;
            option.textContent = rank;
            rankSelect.appendChild(option);
          });

          state.metaColumns = getMetaColumns(state.rows);
          state.metaColumns = state.metaColumns.filter((column) => column !== "All");
          state.metaColumns.unshift("All");
          const groupSelect = document.getElementById("groupSelect");
          groupSelect.innerHTML = "";
          ["None", ...state.metaColumns].forEach((column) => {
            const option = document.createElement("option");
            option.value = column;
            option.textContent = column;
            groupSelect.appendChild(option);
          });

          const mainRefreshButton = document.getElementById("taxonRefresh");
          const updateMainRefreshState = () => {
            mainRefreshButton.disabled = !state.mainDirty;
          };

          rankSelect.addEventListener("change", (event) => {
            state.mainPending.rank = event.target.value;
            state.mainPending.pinnedTaxon = null;
            state.mainDirty = true;
            updateMainRefreshState();
          });
          groupSelect.addEventListener("change", (event) => {
            state.mainPending.groupBy = event.target.value;
            state.mainDirty = true;
            updateMainRefreshState();
          });

          const taxonOrderSelect = document.getElementById("taxonOrderSelect");
          taxonOrderSelect.innerHTML = "";
          [
            { value: "total_desc", label: "Total abundance (desc)" },
            { value: "total_asc", label: "Total abundance (asc)" },
            { value: "alphabetical", label: "Alphabetical" },
          ].forEach((item) => {
            const option = document.createElement("option");
            option.value = item.value;
            option.textContent = item.label;
            taxonOrderSelect.appendChild(option);
          });
          taxonOrderSelect.addEventListener("change", (event) => {
            state.mainPending.taxonOrder = event.target.value;
            state.mainDirty = true;
            updateMainRefreshState();
          });

          const conditionSelect = document.getElementById("conditionSelect");
          conditionSelect.innerHTML = "";
          state.metaColumns.forEach((column) => {
            const option = document.createElement("option");
            option.value = column;
            option.textContent = column;
            conditionSelect.appendChild(option);
          });
          const refreshPanelButton = document.getElementById("taxonRefreshPanel");
          const setLoading = (id, isLoading) => {
            const overlay = document.getElementById(id);
            if (!overlay) return;
            overlay.hidden = !isLoading;
          };
          const updateTaxonRefreshState = () => {
            refreshPanelButton.disabled = !state.taxonDirty;
          };

          state.taxonCondition = state.metaColumns[0] || "All";
          state.taxonColorCondition = "All";
          state.taxonPending = {
            condition: state.taxonCondition,
            abundanceType: state.taxonAbundanceType,
            scale: state.taxonScale,
            colorCondition: state.taxonColorCondition,
          };
          conditionSelect.value = state.taxonPending.condition;
          conditionSelect.addEventListener("change", (event) => {
            state.taxonPending.condition = event.target.value;
            state.taxonDirty = true;
            updateTaxonRefreshState();
          });

          const taxonPinSelect = document.getElementById("taxonPinSelect");
          taxonPinSelect.addEventListener("change", (event) => {
            state.mainPending.pinnedTaxon =
              event.target.value === "None" ? null : event.target.value;
            state.mainDirty = true;
            updateMainRefreshState();
            state.taxonDirty = true;
            updateTaxonRefreshState();
          });

          const topNInput = document.getElementById("topNInput");
          topNInput.value = String(state.topN);
          topNInput.addEventListener("change", (event) => {
            const nextValue = parseInt(event.target.value, 10);
            state.mainPending.topN = Number.isFinite(nextValue) && nextValue > 0 ? nextValue : 15;
            event.target.value = String(state.mainPending.topN);
            state.mainDirty = true;
            updateMainRefreshState();
          });

          if (!state.mainPending) {
            state.mainPending = {
              rank: state.ranks[0] || null,
              groupBy: state.groupBy,
              taxonOrder: state.taxonOrder,
              pinnedTaxon: state.pinnedTaxon,
              topN: state.topN,
              showAllSamples: state.showAllSamples,
            };
          }
          const sampleToggle = document.getElementById("sampleToggle");
          const updateSampleToggle = () => {
            sampleToggle.textContent = state.showAllSamples
              ? "Collapse"
              : "Show all";
          };
          updateSampleToggle();
          sampleToggle.addEventListener("click", () => {
            state.showAllSamples = !state.showAllSamples;
            state.mainPending.showAllSamples = state.showAllSamples;
            updateSampleToggle();
            renderCharts(state.activeRank || state.mainPending.rank, state.groupBy, state.taxonOrder);
          });

          const defaultRank = state.ranks.includes("Genus")
            ? "Genus"
            : state.ranks[0];
          rankSelect.value = defaultRank;
          groupSelect.value = "None";
          taxonOrderSelect.value = state.taxonOrder;
          updatePinOptions(defaultRank, state.groupBy, state.taxonOrder);
          const abundanceTypeSelect = document.getElementById("abundanceTypeSelect");
          abundanceTypeSelect.innerHTML = "";
          [
            { value: "RelativeAbundance", label: "Relative abundance" },
            { value: "AbsoluteAbundance", label: "Absolute abundance" },
          ].forEach((item) => {
            const option = document.createElement("option");
            option.value = item.value;
            option.textContent = item.label;
            abundanceTypeSelect.appendChild(option);
          });
          state.taxonAbundanceType = hasTypeForRank(defaultRank, "RelativeAbundance")
            ? "RelativeAbundance"
            : "AbsoluteAbundance";
          abundanceTypeSelect.value = state.taxonAbundanceType;
          state.taxonPending.abundanceType = state.taxonAbundanceType;
          abundanceTypeSelect.addEventListener("change", (event) => {
            state.taxonPending.abundanceType = event.target.value;
            state.taxonDirty = true;
            updateTaxonRefreshState();
          });
          const taxonScaleSelect = document.getElementById("taxonScaleSelect");
          taxonScaleSelect.innerHTML = "";
          [
            { value: "linear", label: "Linear" },
            { value: "log", label: "Log" },
          ].forEach((item) => {
            const option = document.createElement("option");
            option.value = item.value;
            option.textContent = item.label;
            taxonScaleSelect.appendChild(option);
          });
          taxonScaleSelect.value = state.taxonScale;
          state.taxonPending.scale = state.taxonScale;
          taxonScaleSelect.addEventListener("change", (event) => {
            state.taxonPending.scale = event.target.value;
            state.taxonDirty = true;
            updateTaxonRefreshState();
          });
          const colorConditionSelect = document.getElementById("colorConditionSelect");
          colorConditionSelect.innerHTML = "";
          state.metaColumns.forEach((column) => {
            const option = document.createElement("option");
            option.value = column;
            option.textContent = column;
            colorConditionSelect.appendChild(option);
          });
          colorConditionSelect.value = state.taxonColorCondition;
          state.taxonPending.colorCondition = state.taxonColorCondition;
          colorConditionSelect.addEventListener("change", (event) => {
            state.taxonPending.colorCondition = event.target.value;
            state.taxonDirty = true;
            updateTaxonRefreshState();
          });
          const applyTaxonRefresh = () => {
            state.taxonCondition = state.taxonPending.condition;
            state.taxonAbundanceType = state.taxonPending.abundanceType;
            state.taxonScale = state.taxonPending.scale;
            state.taxonColorCondition = state.taxonPending.colorCondition;
            state.taxonDirty = false;
            updateTaxonRefreshState();
            const scrollY = window.scrollY;
            setLoading("taxonPanelLoading", true);
            requestAnimationFrame(() => {
              try {
                renderTaxonPanel(rankSelect.value);
              } finally {
                setLoading("taxonPanelLoading", false);
                window.scrollTo(0, scrollY);
              }
            });
          };
          refreshPanelButton.addEventListener("click", applyTaxonRefresh);
          updateTaxonRefreshState();
          setLoading("taxonPanelLoading", false);

          state.mainPending = {
            rank: defaultRank,
            groupBy: state.groupBy,
            taxonOrder: state.taxonOrder,
            pinnedTaxon: state.pinnedTaxon,
            topN: state.topN,
            showAllSamples: state.showAllSamples,
          };
          updateMainRefreshState();
          mainRefreshButton.addEventListener("click", () => {
            state.groupBy = state.mainPending.groupBy;
            state.taxonOrder = state.mainPending.taxonOrder;
            state.pinnedTaxon = state.mainPending.pinnedTaxon;
            state.topN = state.mainPending.topN;
            state.showAllSamples = state.mainPending.showAllSamples;
            state.mainDirty = false;
            updateMainRefreshState();
            updatePinOptions(state.mainPending.rank, state.groupBy, state.taxonOrder);
            taxonPinSelect.value = state.pinnedTaxon || "None";
            setLoading("mainChartsLoading", true);
            requestAnimationFrame(() => {
              try {
                renderCharts(state.mainPending.rank, state.groupBy, state.taxonOrder);
              } finally {
                setLoading("mainChartsLoading", false);
              }
            });
            state.taxonDirty = true;
            updateTaxonRefreshState();
          });
          renderCharts(defaultRank, state.groupBy, state.taxonOrder);
          renderTaxonPanel(defaultRank);
          setLoading("mainChartsLoading", false);
          document.getElementById("status").textContent =
            "Loaded " + state.rows.length + " rows.";
        } catch (err) {
          document.getElementById("status").textContent =
            "Failed to load data: " + err;
        }
      }

      init();
    </script>
  </body>
</html>
